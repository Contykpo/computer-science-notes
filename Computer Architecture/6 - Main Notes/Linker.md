
2024-08-28 11:57

Status: #In-Production

Tags: #Development-Process #Linker #GCC #Dynamic-Linking #Static-Linking #Dependency-Hell

# Linker

It is a program capable of taking the object program recently generated by the compiler, linking it with other object programs and with other code libraries and generating a program executable by the Operating System on which we are developing our program.

#### Linking Means:

- Put all the code blocks together and organize code and data into common sections and then save that set in a single executable file.
- Once organized, resolve each reference to a variable or function that was external during the compilation phase. In our case, the linker will resolve the reference to **printf()**.
- Identify and mark the entry point of the program (the address that will be assigned to **main**).

It may seem unimportant. However, this phase of our program generation is **crucial**.
There are several objects involved, as we can see, which are relevant: *crt1.o, crti.o, crtbegin.o, crtend.o*. It is **cumbersome**, **impossible to memorize**, and above all, subject to internal system issues.

That is why #GCC calls the linker and saves us the trouble of linking the necessary files ourselves.

```
// Console command to generate an executable file:

gcc -hello hello.o -Wall

// Console command to print how the #GCC makes the call: (-v parameter stands for vervose).

gcc -hello hello.o -v
```

## Dynamic Linking vs. Static Linking:

#### Dynamic Linking:

#Dynamic-Linking loads libraries at runtime rather than at compile time. The executable includes references to the library code, but the code itself is stored in shared libraries (`.so` files). The executable relies on external shared libraries to provide the necessary functionality.

The  main advantages are:

- Smaller executable size, as libraries are not included directly in the executable.
- Flexibility: Shared libraries can be updated independently of the executable, benefiting from updates without recompiling.
- Memory efficiency: Shared libraries can be loaded into memory once and shared among multiple executables, saving system resources.

But comes with the disadvantages:

- Slower startup time due to the overhead of loading libraries at runtime.
- **Dependency management**: Executables require the correct versions of shared libraries at runtime, which can lead to issues like #Dependency-Hell

**Dependency Hell** (**DLL Hell**' in Windows systems): 
When a shared library is updated, all applications linked to it must also be updated. Failure to do so can lead to inconsistencies and conflicts, a phenomenon colloquially known as “**DLL Hell**”. This occurs when applications require different versions of a shared library, leading to [version conflicts](https://johnfarrier.com/algorithmic-semver/) and potential application failures.

#### Static Linking:

#Static-Linking involves including all necessary library code directly into the executable at compile time. The resulting executable is self-contained, meaning it has no dependencies on external libraries at runtime.

The main advantages are:

- Faster execution, as all library code is already in the executable.
- No dependency issues at runtime since everything is bundled into the executable.
- Easier distribution of executables, as they don't require external libraries.

But comes with the disadvantages:

- Larger executable size because all library code is included.
- Less flexibility: if a library needs an update (e.g., for a security patch), the executable must be recompiled with the updated library.


# References

- [[Development Process.canvas|Development Process]].
- [Dynamic Linking vs. Static Linking](https://johnfarrier.com/demystifying-static-vs-dynamic-linking-in-c/).
- [Version Conflicts](https://johnfarrier.com/algorithmic-semver/)
